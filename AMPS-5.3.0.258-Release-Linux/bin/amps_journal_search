#!/usr/bin/env python
############################################################################
##
## Copyright (c) 2017 60East Technologies Inc., All Rights Reserved.
##
## This computer software is owned by 60East Technologies Inc. and is
## protected by U.S. copyright laws and other laws and by international
## treaties.  This computer software is furnished by 60East Technologies
## Inc. pursuant to a written license agreement and may be used, copied,
## transmitted, and stored only in accordance with the terms of such
## license agreement and with the inclusion of the above copyright notice.
## This computer software or any other copies thereof may not be provided
## or otherwise made available to any other person.
##
## U.S. Government Restricted Rights.  This computer software: (a) was
## developed at private expense and is in all respects the proprietary
## information of 60East Technologies Inc; (b) was not developed with
## government funds; (c) is a trade secret of 60East Technologies Inc.
## for all purposes of the Freedom of Information Act; and (d) is a
## commercial item and thus, pursuant to Section 12.212 of the Federal
## Acquisition Regulations (FAR) and DFAR Supplement Section 227.7202,
## Government's use, duplication or disclosure of the computer software
## is subject to the restrictions set forth by 60East Technologies Inc.
##
############################################################################

###
### This is a tool to binary-search journals for a message with a given bookmark
### or txid, and do so much faster than dumping every journal.
###

from __future__ import absolute_import
from __future__ import print_function
import glob, os, sys

# Before doing anything, check that we're running at least version 2.5
if ''.join(map(str, sys.version_info[0:3])) < '250':
    die('Error: %s requires Python 2.5 or greater.\n' % sys.argv[0])

# Insert the lib directory into PYTHONPATH
sys.path.append(os.path.join(os.path.dirname(sys.argv[0]), "lib"))
import amps_journal


if len(sys.argv) < 3:
    print("""
usage: amps_journal_search -data <search-string> <journal-files> 
       amps_journal_search <search-pattern> <journal-files>

    -data: search for all records containing <search-string>, and if <search-string> is a bookmark,
           also include records matching this bookmark.

    <search-pattern>: one of
    
       bookmark:        search the journals for a message with the given client name hash and sequence;
       transaction id:  search for a message with the given local transaction id

    <journal-files>: list of .journal or .journal.gz files to be searched.
""", file=sys.stderr)
    sys.exit(-1)

def first_for_client(filename,clientNameHash):
    print("open ",filename)
    journal = amps_journal.open_file(filename)
    for record in journal.records():
        if record["clientNameHash"] == clientNameHash:
            return record
    return None

def bisect(files,clientNameHash,clientSeq):
    if len(files) == 1:
        journal = amps_journal.open_file(files[0])
        print("finding in ", files[0])
        for record in journal.records():
            if clientSeq == record["clientSeq"] and clientNameHash == record["clientNameHash"]:
                return record
        return "Not found."
    else:
        idx = len(files)/2
        filename = files[idx]
        ffc = first_for_client(filename,clientNameHash)
        if ffc is None:
            del files[idx]
            return bisect(files,clientNameHash,clientSeq)
        ffc_clientSeq = ffc["clientSeq"]
        if ffc_clientSeq == clientSeq:
            return ffc
        elif ffc_clientSeq > clientSeq:
            return bisect(files[0:idx],clientNameHash,clientSeq)
        else:
            return bisect(files[idx:],clientNameHash,clientSeq)

def search_bookmark(files,bookmark):
    parts = bookmark.split('|')
    clientNameHash = int(parts[0])
    clientSeq = int(parts[1])
    return bisect(files,clientNameHash,clientSeq)

def search_txid(files,pat):
    txid = 0
    try:
        txid = int(pat)
    except:
        return "Invalid transaction id or bookmark: %s"%pat

    for filename in files:
        journal = amps_journal.open_file(filename)
        extents = journal.getExtents()
        if txid>= extents[0] and (txid<= extents[2] or extents[2] == 0):
            print("should be in ",filename)
            for record in journal.records():
                if record["localTxId"] == txid:
                    return record
            return "Not found."
    return "Not found -- no journal seems to cover that txid."

def search_data(files,pat):
    clientSeq = 0
    clientNameHash = 0
    isBookmark = False
    if pat.find('|') != -1:
        try:
            parts = pat.split('|')
            clientNameHash = int(parts[0])
            clientSeq = int(parts[1])
            isBookmark = True
        except:
            print("warning: pattern contains pipe delimiter, but could not be parsed as a bookmark.")
    
    for filename in files:
        print("===",filename)
        journal = amps_journal.open_file(filename)
        for record in journal.records():
            if  ('data' in record and record['data'].find(pat) != -1) \
             or ('key' in record and record['key'].find(pat) != -1) \
             or (isBookmark and record["clientNameHash"] == clientNameHash and record["clientSeq"] == clientSeq):
                print(record)
                
pat = sys.argv[1]
files = []
isData = False
if pat == "-data":
    pat = sys.argv[2]
    files = sys.argv[3:]
    isData = True
else:
    files = sys.argv[2:]

## Allow the journal files to be specified in any order and reorder them by serial.
files.sort()

if isData:
    search_data(files,pat)
elif pat.find('|') == -1:
    print(search_txid(files,pat))
else:
    print(search_bookmark(files,pat))



